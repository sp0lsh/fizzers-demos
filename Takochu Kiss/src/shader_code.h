/* File generated with Shader Minifier 1.1.1
 * http://www.ctrl-alt-test.fr
 */
#ifndef SHADER_CODE_H_
# define SHADER_CODE_H_

const char fragment_glsl[] = ""
 "#version 130\n"
 "vec2 n(vec2 v,vec2 f)"
 "{"
   "return mix(v,f,step(f.y,v.y));"
 "}"
 "float p(vec3 v,vec3 y)"
 "{"
   "return max(max(abs(v.x)-y.x,abs(v.y)-y.y),abs(v.z)-y.z);"
 "}"
 "float n(float y,float z,float x)"
 "{"
   "return-log(exp(-x*y)+exp(-x*z))/x;"
 "}"
 "mat2 n(float v)"
 "{"
   "return mat2(cos(v),sin(v),-sin(v),cos(v));"
 "}"
 "float p(vec3 v)"
 "{"
   "vec3 f=vec3(0,-.08,.52);"
   "float s=distance(v,vec3(f.xy+normalize(v.xy-f.xy)*.08,clamp(v.z,0,f.z)))-.052,m=length(v)-.5;"
   "vec3 i=vec3(0,-.4,.4)*.97,r=v;"
   "r.xz=abs(r.xz);"
   "if(r.z>r.x)"
     "r.xz=r.zx;"
   "r.xz*=n(-acos(-1.)/2.65);"
   "r.yz=(r.yz-i.yz)*n(-.7)+i.yz;"
   "float z=distance(r,vec3(i.xy+normalize(r.xy-i.xy)*clamp(length(r.xy-i.xy),0.,.1),i.z))-.04,c=length(v)-1.;"
   "if(c>1)"
     "return c;"
   "return n(n(m,s,50),z,30);"
 "}"
 "float f(vec3 v)"
 "{"
   "return v.x=abs(v.x),step(0,distance(v,vec3(.35,-.06,.5))-.122);"
 "}"
 "float v(vec3 v)"
 "{"
   "vec3 f=vec3(0,-.08,.52);"
   "float z=distance(v,vec3(f.xy+normalize(v.xy-f.xy)*.08,clamp(v.z,0,f.z)))-.022;"
   "return step(.005,z);"
 "}"
 "vec2 f(vec3 y,float z)"
 "{"
   "if(f(y)<.5)"
     "z=4;"
   "if(v(y)<.5)"
     "z=5;"
   "return vec2(z,p(y));"
 "}"
 "float r=0,i=0;"
 "vec2 e(vec3 v)"
 "{"
   "vec3 y=v;"
   "vec2 m=vec2(0,100);"
   "if(r<.5)"
     "m=vec2(0,v.y+.48);"
   "m=n(m,f(y,1));"
   "y+=vec3(1.1,0,0);"
   "y.xz*=n(-1.4);"
   "m=n(m,f(y,1));"
   "i=m.x;"
   "return m;"
 "}"
 "float x(vec3 v)"
 "{"
   "return e(v/6).y*6-.14;"
 "}"
 "float e(vec3 v,vec3 y,vec3 z)"
 "{"
   "return v=abs(v-z),max(v.x-y.x,max(v.y-y.y,v.z-y.z));"
 "}"
 "float f(vec3 v,vec3 y,vec3 z)"
 "{"
   "return length(max(vec3(0),abs(v-z)-y));"
 "}"
 "float s(vec3 v)"
 "{"
   "return min(min(min(min(x(v/8.)*8.,f(v,vec3(10,10,0),vec3(0,50,0))-4),f(v,vec3(10,10,0),vec3(-53,50,0))-4),f(v,vec3(0,0,0),vec3(-53,32,0))-3),f(v,vec3(0,0,0),vec3(0,32,0))-3);"
 "}"
 "float p(vec3 v,vec3 y,vec3 z)"
 "{"
   "return distance(v,mix(y,z,clamp(dot(v-y,normalize(z-y))/distance(y,z),0.,1.)));"
 "}"
 "vec4 m(vec2 v)"
 "{"
   "r=0;"
   "i=0;"
   "vec4 m=vec4(0);"
   "vec3 y=vec3(.5,.5,1);"
   "float z=0;"
   "vec2 c=v.xy;"
   "vec3 x=normalize(vec3(1,0,0)),l=normalize(vec3(0,1,0)),n=normalize(cross(l,x));"
   "float g=.4;"
   "x=cos(g)*x+sin(g)*n;"
   "n=normalize(cross(l,x));"
   "g=.5;"
   "l=cos(g)*l+sin(g)*n;"
   "n=normalize(cross(l,x));"
   "vec3 d=vec3(-11,35,40)+(c.x*x+c.y*l)*100,a=n+.001,w=d;"
   "a=normalize(a);"
   "vec3 o=a,t=vec3(1.),h=vec3(0.),k;"
   "for(int b=0;b<4;++b)"
     "{"
       "vec3 u=d;"
       "float F=-7;"
       "for(int C=0;C<30;++C)"
         "{"
           "d=u+a*F;"
           "float Z=s(d);"
           "if(Z<.0001)"
             "{"
               "break;"
             "}"
           "F+=Z;"
         "}"
       "u=d;"
       "vec3 C=floor(d),Z=(C+max(vec3(0.),sign(a))-d)/a;"
       "for(int Y=0;Y<30;++Y)"
         "{"
           "k=step(Z,Z.yzx)*step(Z,Z.zxy);"
           "C+=sign(a)*k;"
           "float X=s(C);"
           "vec3 W=sign(a)/a*k;"
           "if(X<-1.4)"
             "{"
               "d=u+a*min(Z.x,min(Z.y,Z.z));"
               "break;"
             "}"
           "Z+=W;"
         "}"
       "d=u+a*min(Z.x,min(Z.y,Z.z));"
     "}"
   "float C=.0013,Z=1;"
   "{"
     "d-=a*1e-05;"
     "vec3 u=d,b=normalize(vec3(1,2,-.5)),Y=floor(d),F=(Y+max(vec3(0.),sign(b))-d)/b,W;"
     "for(int X=0;X<60;++X)"
       "{"
         "W=step(F,F.yzx)*step(F,F.zxy);"
         "Y+=sign(b)*W;"
         "float V=s(Y);"
         "vec3 U=sign(b)/b*W;"
         "if(V<-1.4)"
           "{"
             "Z=.4;"
             "break;"
           "}"
         "F+=U;"
       "}"
   "}"
   "vec3 u=d*(vec3(1)-k),b=vec3(1);"
   "b*=mix(.25,1,smoothstep(0.,40.,length((vec3(0,-18,0)*1.5-d)*vec3(1,3,1))));"
   "b*=mix(.25,1,smoothstep(0.,40.,length((vec3(-35,-18,0)*1.5-d)*vec3(1,3,1))));"
   "s(ceil(d));"
   "z=i;"
   "if(d.y<-22.9)"
     "r=1,b*=mix(.8,1.,smoothstep(-4,2,s(d))),b*=vec3(1,.7,.45);"
   "else"
     "{"
       "b*=mix(vec3(1),vec3(1,.7,.45),.5*(1.-smoothstep(0,55,d.y+22)));"
       "if(d.x<-24&&d.y<30)"
         "b*=vec3(1,.9,1);"
       "if(e(floor(d-.001),vec3(1,5,10),vec3(10,4,20))<0)"
         "b*=.35;"
       "if(e(floor(d-.001),vec3(1,5,10),vec3(-10,4,20))<0)"
         "b*=.35;"
       "if(e(floor(d-.001),vec3(10,1,4),vec3(-35,4,15))<0)"
         "b*=.35;"
       "if(length(floor(d).xy-vec2(0,-4))<2)"
         "b*=.35;"
       "if(length(floor(d).xy-vec2(12,-6))<3.5)"
         "b*=vec3(1,.8,.8);"
       "if(length(floor(d).xy-vec2(-12,-6))<3.5)"
         "b*=vec3(1,.8,.8);"
       "float X=min(f(floor(d),vec3(0,4,0),vec3(0,53,4))-2.5,f(floor(d),vec3(0,0,0),vec3(0,42,4))-2.5);"
       "if(X<0)"
         "b*=.55;"
       "float Y=min(p(floor(d),vec3(-53,47,0),vec3(-48,52,0)),p(floor(d),vec3(-53,47,0),vec3(-58,52,0)))-5.95;"
       "if(Y<-.9)"
         "b*=vec3(1,.8,.8);"
       "else"
         " if(Y<0)"
           "b*=.55;"
       "if(f(floor(d),vec3(0),vec3(-48,53,0))<3.2)"
         "b=vec3(1);"
     "}"
   "m.w=1;"
   "m.xyz=b*(.75+.25*dot(k*-sign(a),normalize(vec3(1,2,1.4))))*smoothstep(-3.,-1,s(d-vec3(.1)))*mix(vec3(.6,.6,.8),vec3(1),Z);"
   "m*=mix(.7,1.,smoothstep(0.,40.,distance(d,vec3(-65,-10,2))));"
   "m*=mix(.7,1.,smoothstep(0.,40.,distance(d,vec3(-8,-10,2))));"
   "float Y=exp(-distance(d,w)*C);"
   "m.xyz=mix(y,m.xyz,Y);"
   "m*=max(min(1.,exp(-(length(v.xy)-.5)*1))/3,step(length(v.xy),.7))*1.12;"
   "return m;"
 "}"
 "void main()"
 "{"
   "vec2 v=gl_FragCoord.xy/vec2(1920,1080)*2.-vec2(1);"
   "v.x*=1.77778;"
   "v*=.8;"
   "gl_FragColor=vec4(0);"
   "for(int z=-1;z<=1;++z)"
     "for(int y=-1;y<=1;++y)"
       "gl_FragColor+=m(v.xy+vec2(y,z)*.0005);"
   "gl_FragColor/=9.;"
   "gl_FragColor.xyz+=vec3(cos(gl_FragCoord.y*7)*cos(gl_FragCoord.x*5)*.5+.5)/100.;"
 "}";

#endif // SHADER_CODE_H_
